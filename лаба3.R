# 3 –õ–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞—è —Ä–∞–±–æ—Ç–∞: AR(p)ARCH(q) –∏ —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
# 1. –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å AR(2)ARCH(3) –ø—Ä–æ—Ü–µ—Å—Å –∏–∑ n = 2100 –Ω–∞–±–ª—é–¥–µ–Ω–∏–π —Å –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ 
# –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ ùúÉ= (‚àí0.3, 0.4)‚Ä≤, ùê¥ = (1, 0.2, 0.1, 0.2)‚Ä≤ –∏ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –µ–≥–æ –≥—Ä–∞—Ñ–∏–∫.

n = 2100 # –∫–æ–ª-–≤–æ –Ω–∞–±–ª—é–¥–µ–Ω–∏–π
theta = c(-0.3, 0.4)
A = c(1, 0.2, 0.1, 0.2) # –≤–µ–∫—Ç–æ—Ä –∑–Ω–∞—á–µ–Ω–∏–π ai

# –§—É–Ω–∫—Ü–∏—è –¥–ª—è AR(2)ARCH(3) –ø—Ä–æ—Ü–µ—Å—Å–∞
AR2_ARCH3 = function(a, theta) 
{
  x = numeric(n) # –∑–Ω–∞—á–µ–Ω–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞
  sigma = numeric(n)
  eps = rnorm(n,0,1) # –æ—à–∏–±–∫–∏
  # –ù–∞—á–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
  sigma[1] = a[1]
  x[1] = sqrt(sigma[1])*eps[1]
  sigma[2] = a[1] + a[2]*x[1]^2 
  x[2] = theta[1]*x[1] + sqrt(sigma[2])*eps[2]
  sigma[3] = a[1] + a[2]*x[2]^2 + a[3]*x[1]^2
  x[3] = theta[1]*x[2] + theta[2]*x[1] + sqrt(sigma[3])*eps[3]
  # –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª
  for (i in 4:n) 
  {
    sigma[i] = a[1] + a[2]*x[i-1]^2 + a[3]*x[i-2]^2 + a[4]*x[i-3]^2
    x[i] = theta[1]*x[i-1] + theta[2]*x[i-2] + sqrt(sigma[i])*eps[i]
  }
  plot(x, type = 'l', main = "AR(2)ARCH(3) –ø—Ä–æ—Ü–µ—Å—Å:") # –≥—Ä–∞—Ñ–∏–∫ –ø—Ä–æ—Ü–µ—Å—Å–∞
  x
}
  
x = AR2_ARCH3(A, theta)

# 2. –†–∞–∑–¥–µ–ª–∏—Ç—å, –ø–æ–ª—É—á–µ–Ω–Ω—É—é –Ω–∞ –ø–µ—Ä–≤–æ–º —à–∞–≥–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å {xn}, 
# –≤ –æ—Ç–Ω–æ—à–µ–Ω–∏–∏ 20 : 1 –Ω–∞ –æ–±—É—á–∞—é—â—É—é –∏ —Ç–µ—Å—Ç–æ–≤—É—é –≤—ã–±–æ—Ä–∫–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ.

n1 = 2000 # –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –≤—ã–±–æ—Ä–∫–∏ 2000 –∫ 100
n2 = 100

h_train = x[1 : n1] # –û–±—É—á–∞—é—â–∞—è –≤—ã–±–æ—Ä–∫–∞ (1:2000)
h_test = x[(n1+1) : n] # –¢–µ—Å—Ç–æ–≤–∞—è –≤—ã–±–æ—Ä–∫–∞ (2001:2100)

# 3. –ù–∞ –æ—Å–Ω–æ–≤–µ –æ–±—É—á–∞—é—â–µ–π –≤—ã–±–æ—Ä–∫–∏ –ø–æ–ª—É—á–∏—Ç—å –æ—Ü–µ–Ω–∫–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ ùúÉ = (ùúÉ1, ùúÉ2)‚Ä≤ –∏ ùê¥ = (ùëé0, ùëé1, ùëé2, ùëé3)‚Ä≤.
library("tseries")
# –û—Ü–µ–Ω–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ ùúÉ –¥–ª—è –ø—Ä–æ—Ü–µ—Å—Å–∞ AR(2)
a = arima(h_train, order = c(2, 0, 0), include.mean = FALSE)
theta1 = c(a$coef[1], a$coef[2]); theta1

h = numeric(n1)
# –ù–∞—á–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
h[1] = h_train[1]
h[2] = h_train[2] - theta1[1]*h_train[1]
# –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª
for (i in 3 : n1)
{
  h[i] = h_train[i] - theta1[1]*h_train[i-1] - theta1[2]*h_train[i-2]
}
# –û—Ü–µ–Ω–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ A –¥–ª—è –ø—Ä–æ—Ü–µ—Å—Å–∞ ARCH(3)
g = garch(h, order = c(0, 3), start = A)
A1 = c(g$coef[1], g$coef[2], g$coef[3], g$coef[4]); A1

# 4. –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø—Ä–æ–≥–Ω–æ–∑–æ–≤ –Ω–∞ –æ–¥–∏–Ω —à–∞–≥ –Ω–∞ —Ç–µ—Å—Ç–æ–≤–æ–π –≤—ã–±–æ—Ä–∫–µ. 
# –ù–∞–ª–æ–∂–∏—Ç—å –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø—Ä–æ–≥–Ω–æ–∑–æ–≤ –Ω–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –Ω–∞–±–ª—é–¥–µ–Ω–∏–π –ø—Ä–æ—Ü–µ—Å—Å–∞. 

# –≥—Ä–∞—Ñ–∏–∫ –ø—Ä–æ—Ü–µ—Å—Å–∞
plot(h_test, type = 'l', col = 'turquoise', main = "–ì—Ä–∞—Ñ–∏–∫ –ø–æ—Å–ª –ø—Ä–æ–≥–Ω–æ–∑–æ–≤ –∏ –Ω–∞–±–ª—é–¥–µ–Ω–∏–π –ø—Ä–æ—Ü–µ—Å—Å–∞:")
prediction = function(h_test, theta, a) 
{
  x = array(n2) # –ø–æ—Å–ª –ø—Ä–æ–≥–Ω–æ–∑–æ–≤ –Ω–∞ 1 —à–∞–≥ {ùë•ùëõ+1|ùëõ}
  sigma = array(n2)
  upbound = array(n2) # –≤–µ—Ä—Ö–Ω—è—è –∏ –Ω–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü—ã –ø—Ä–æ–≥–Ω–æ–∑–∞ 
  lbound = array(n2)
  # –ù–∞—á–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è  
  x[1] = 0
  x[2] = theta[1]*h_test[1]
  x[3] = theta[1]*h_test[2] + theta[2]*h_test[1]
  sigma[1] = a[1]
  sigma[2] = a[1] + a[2]*h_test[1]^2
  sigma[3] = a[1] + a[2]*h_test[2]^2 + a[3]*h_test[1]^2
  # –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –ø–æ—Å–ª –ø—Ä–æ–≥–Ω–æ–∑–æ–≤
  for(i in 4 : n2) 
  {
    x[i] = theta[1]*h_test[i-1] + theta[2]*h_test[i-2]
    sigma[i] = a[1] + a[2]*h_test[i-1]^2 + a[3]*h_test[i-2]^2 + a[4]*h_test[i-3]^2
  } 
  for(i in 1 : n2) # –ù–∞—Ö–æ–∂–¥–µ–Ω–∏–µ –≥—Ä–∞–Ω–∏—Ü
  {
    upbound[i] = x[i] + sqrt(sigma[i])
    lbound[i] = x[i] - sqrt(sigma[i])
  }
  
  lines(x, type = 'p', col = 'black') # –ù–∞–ª–æ–∂–µ–Ω–∏–µ –ø–æ—Å–ª –ø—Ä–æ–≥–Ω–æ–∑–æ–≤ –Ω–∞ –æ–¥–∏–Ω —à–∞–≥ –Ω–∞ –ø–æ—Å–ª –Ω–∞–±–ª—é–¥–µ–Ω–∏–π –ø—Ä–æ—Ü–µ—Å—Å–∞
  # –ù–∞–ª–æ–∂–µ–Ω–∏–µ –≥—Ä–∞–Ω–∏—Ü –ø—Ä–æ–≥–Ω–æ–∑–∞ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞
  lines(upbound, lty = 2, col = 'red')
  lines(lbound, lty = 2, col = 'red')
}

prediction(h_test, theta1, A1)

# 5. –°–∫–∞—á–∞—Ç—å —Å —Å–∞–π—Ç–∞ https://www.finam.ru/ –ª—é–±—ã–µ –¥–Ω–µ–≤–Ω—ã–µ –∫–æ—Ç–∏—Ä–æ–≤–∫–∏ —Ñ–∏–Ω–∞–Ω—Å–æ–≤—ã—Ö 
# –∞–∫—Ç–∏–≤–æ–≤ –∏–ª–∏ –∑–Ω–∞—á–µ–Ω–∏—è –∏–Ω–¥–µ–∫—Å–æ–≤ (–º–∏–Ω–∏–º—É–º –∑–∞ 3 –≥–æ–¥–∞). 
# 6. –ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–∫–∞—á–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ R, –∏—Å–ø–æ–ª—å–∑—É—è —Ñ—É–Ω–∫—Ü–∏—é readtable();

# –Ø –≤–∑—è–ª–∞ –¥–∞–Ω–Ω—ã–µ –ì–∞–∑–ø—Ä–æ–º–∞ –∑–∞ 4 –≥–æ–¥–∞
data = read.csv("C:\\Users\\cherk_3rh9yom\\OneDrive\\–†–∞–±–æ—á–∏–π —Å—Ç–æ–ª\\–≠–ú–ú2\\GAZP_201101_241101.csv", sep = ";")
str(data)

# 7. –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –≥—Ä–∞—Ñ–∏–∫ –¥–∏–Ω–∞–º–∏–∫–∏ –∞–∫—Ç–∏–≤–∞
plot(data$X.HIGH, type = 'l', main = "–ì—Ä–∞—Ñ–∏–∫ –¥–∏–Ω–∞–º–∏–∫–∏ –∞–∫—Ç–∏–≤–∞:") 

# 8. –ü—Ä–∏–≤–µ—Å—Ç–∏ –¥–∞–Ω–Ω—ã–µ –∫ —Å—Ç–∞—Ü–∏–æ–Ω–∞—Ä–Ω–æ–º—É –≤–∏–¥—É, –∏—Å–ø–æ–ª—å–∑—É—è –æ–¥–Ω–æ –∏–∑ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π
# zk = (ùëÉùëò ‚àí ùëÉùëò‚àí1) /ùëÉùëò‚àí1, –∏–ª–∏ zk = ln ùëÉùëò/ùëÉùëò‚àí1, ùëò ‚â• 1.
# 9. –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –≥—Ä–∞—Ñ–∏–∫ –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç–µ–π {zk} —Ñ–∏–Ω–∞–Ω—Å–æ–≤–æ–≥–æ –∞–∫—Ç–∏–≤–∞;
p = data$X.HIGH
z = array(nrow(data))
z[1] = 0
for(k in 2 : nrow(data))
  z[k] = log(p[k]/p[k - 1])
plot(z, type = 'l', main = "–ì—Ä–∞—Ñ–∏–∫ –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç–µ–π {zk} —Ñ–∏–Ω–∞–Ω—Å–æ–≤–æ–≥–æ –∞–∫—Ç–∏–≤–∞:")

# 10. –ü–æ–≤—Ç–æ—Ä–∏—Ç—å —à–∞–≥–∏ 2-4 –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ {zn} –ø—Ä–∏ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏–∏,
# —á—Ç–æ –ø—Ä–æ—Ü–µ—Å—Å {zn} –æ–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è –º–æ–¥–µ–ª—å—é AR(2)ARCH(3).

# 2) –†–∞–∑–¥–µ–ª–∏—Ç—å, –ø–æ–ª—É—á–µ–Ω–Ω—É—é –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å {zn}, –≤ –æ—Ç–Ω–æ—à–µ–Ω–∏–∏ 20 : 1
# –Ω–∞ –æ–±—É—á–∞—é—â—É—é –∏ —Ç–µ—Å—Ç–æ–≤—É—é –≤—ã–±–æ—Ä–∫–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ.

n = nrow(data); n # –û–±—ä–µ–º –¥–∞–Ω–Ω—ã—Ö
# –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –æ–±—É—á–∞—é—â–µ–π –∏ —Ç–µ—Å—Ç–æ–≤–æ–π –≤—ã–±–æ—Ä–æ–∫
train_size = floor(0.95 * n); train_size
test_size = n - train_size; test_size
# –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –æ–±—É—á–∞—é—â—É—é –∏ —Ç–µ—Å—Ç–æ–≤—É—é –≤—ã–±–æ—Ä–∫–∏
z_train = z[1:train_size]
z_test = z[(train_size+1):n]

# 3) –ù–∞ –æ—Å–Ω–æ–≤–µ –æ–±—É—á–∞—é—â–µ–π –≤—ã–±–æ—Ä–∫–∏ –ø–æ–ª—É—á–∏—Ç—å –æ—Ü–µ–Ω–∫–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ ùúÉ = (ùúÉ1, ùúÉ2)‚Ä≤ –∏ ùê¥ = (ùëé0, ùëé1, ùëé2, ùëé3)‚Ä≤.
# –û—Ü–µ–Ω–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ ùúÉ –¥–ª—è –ø—Ä–æ—Ü–µ—Å—Å–∞ AR(2)
a2 = arima(z_train, order = c(2, 0, 0), include.mean = FALSE)
theta1 = c(a2$coef[1], a2$coef[2]); theta1

zz = numeric(train_size)
# –ù–∞—á–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
zz[1] = z_train[1]
zz[2] = z_train[2] - theta1[1]*z_train[1]
# –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª
for (i in 3 : train_size)
{
  zz[i] = z_train[i] - theta1[1]*z_train[i-1] - theta1[2]*z_train[i-2]
}
# –û—Ü–µ–Ω–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ A –¥–ª—è –ø—Ä–æ—Ü–µ—Å—Å–∞ ARCH(3)
g = garch(zz, order = c(0, 3), start = A)
A1 = c(g$coef[1], g$coef[2], g$coef[3], g$coef[4]); A1

# 4) –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø—Ä–æ–≥–Ω–æ–∑–æ–≤ –Ω–∞ –æ–¥–∏–Ω —à–∞–≥ –Ω–∞ —Ç–µ—Å—Ç–æ–≤–æ–π –≤—ã–±–æ—Ä–∫–µ. 
# –ù–∞–ª–æ–∂–∏—Ç—å –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø—Ä–æ–≥–Ω–æ–∑–æ–≤ –Ω–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –Ω–∞–±–ª—é–¥–µ–Ω–∏–π –ø—Ä–æ—Ü–µ—Å—Å–∞. 

# –≥—Ä–∞—Ñ–∏–∫ –ø—Ä–æ—Ü–µ—Å—Å–∞
plot(z_test, type = 'l', col = 'turquoise', main = "–ì—Ä–∞—Ñ–∏–∫ –ø–æ—Å–ª –ø—Ä–æ–≥–Ω–æ–∑–æ–≤ –∏ –Ω–∞–±–ª—é–¥–µ–Ω–∏–π –ø—Ä–æ—Ü–µ—Å—Å–∞:")
prediction = function(z_test, theta, a) 
{
  x = array(n2) # –ø–æ—Å–ª –ø—Ä–æ–≥–Ω–æ–∑–æ–≤ –Ω–∞ 1 —à–∞–≥ {zùëõ+1|ùëõ}
  sigma = array(n2)
  upbound = array(n2) # –≤–µ—Ä—Ö–Ω—è—è –∏ –Ω–∏–∂–Ω—è—è –≥—Ä–∞–Ω–∏—Ü—ã –ø—Ä–æ–≥–Ω–æ–∑–∞ 
  lbound = array(n2)
  # –ù–∞—á–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è  
  x[1] = 0
  x[2] = theta[1]*z_test[1]
  x[3] = theta[1]*z_test[2] + theta[2]*z_test[1]
  sigma[1] = a[1]
  sigma[2] = a[1] + a[2]*z_test[1]^2
  sigma[3] = a[1] + a[2]*z_test[2]^2 + a[3]*z_test[1]^2
  # –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –ø–æ—Å–ª –ø—Ä–æ–≥–Ω–æ–∑–æ–≤
  for(i in 4 : n2) 
  {
    x[i] = theta[1]*z_test[i-1] + theta[2]*z_test[i-2]
    sigma[i] = a[1] + a[2]*z_test[i-1]^2 + a[3]*z_test[i-2]^2 + a[4]*z_test[i-3]^2
  } 
  for(i in 1 : n2) # –ù–∞—Ö–æ–∂–¥–µ–Ω–∏–µ –≥—Ä–∞–Ω–∏—Ü
  {
    upbound[i] = x[i] + sqrt(sigma[i])
    lbound[i] = x[i] - sqrt(sigma[i])
  }
  
  lines(x, type = 'p', col = 'black') # –ù–∞–ª–æ–∂–µ–Ω–∏–µ –ø–æ—Å–ª –ø—Ä–æ–≥–Ω–æ–∑–æ–≤ –Ω–∞ –æ–¥–∏–Ω —à–∞–≥ –Ω–∞ –ø–æ—Å–ª –Ω–∞–±–ª—é–¥–µ–Ω–∏–π –ø—Ä–æ—Ü–µ—Å—Å–∞
  # –ù–∞–ª–æ–∂–µ–Ω–∏–µ –≥—Ä–∞–Ω–∏—Ü –ø—Ä–æ–≥–Ω–æ–∑–∞ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞
  lines(upbound, lty = 2, col = 'red')
  lines(lbound, lty = 2, col = 'red')
}

prediction(z_test, theta1, A1)
